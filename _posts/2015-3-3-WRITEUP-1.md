---
title: "学校发的Challenge的writeup"
description: "好久没更新博客了，做了些好玩的东西还没来得及发上来，以后还是整理下发博客上好了。先把在学校发的challenge的writeup写上好了，虽然日志上访问的人不是很多也没人给答案，隔了这么久自己再做一遍重新玩一下也好。"
layout: post
---

好久没更新博客了＝ ＝做了些东西也没发出去，以后还是发博客上分享一下好了，也好久没和小伙伴联系-0 –

先把在学校发的challenge的writeup写上好了，虽然日志上访问的人也不是很多也没人给答案，，隔了这么久再写自己重新玩一下也好。

首先是题目:

	题目文件：106.186.112.88/temp.zip
	加密服务 106.186.112.88:8097
	Hint:
	1、最后一次加密用的AES的密钥与加密服务所用的key是相同的
	2、第一次加密是异或加密（不会很大）
	最后的明文里会有邮箱及用[]括起来的flag，请将flag及你的联系方式发送到那个邮箱，我会联系你。

先把文件下下来，发现大小都不一样＝ ＝艾玛，甩进十六进制编辑器（懒，就直接拿正2015-4-28在用的st2打开了）

![original_calc](/res/uploads/Original_calc.jpg)

上图为原版计算器

![modified_calc](/res/uploads/Modified_calc.jpg)

这个为大小增加的盗版计算器，后面多了一串“无意义”的字符串

看看加密服务：

![encryption_service](/res/uploads/service.jpg)

发现，输入的内容较少的时候（准确的来说应该是少于或等于七位），返回的东西都是一串长度为16的十进制数字，而且还提示了用的key是相同的，你和我说不是异或我都不信啊。。

然后再用一个小trick，单纯异或加密会碰到的一个小问题：

![xor_problem](/res/uploads/xor_problem_demonstration.jpg)

如果知道原文和异或后的密文，对这两者进行异或操作可以得到异或密钥

	>>> int('test'.encode('hex'),16) ^ 1673539920967039
	1673538652390923

顺便把服务器端加密服务的代码贴出来

	#!/usr/bin/env python
	from SocketServer import TCPServer, ThreadingMixIn, StreamRequestHandler
	import time
	def en(c, key):
	    return int(c.encode('hex'), 16) ^ key
	class Server(ThreadingMixIn, TCPServer): pass
	class Handler(StreamRequestHandler):
		def handle(self):
			addr = self.request.getpeername()
			print "Got connection from " + addr[0]
			print time.ctime()
			self.wfile.write("Enter text:\n")
			text = self.rfile.readline()
			try:
				text = text[:text.find('\r\n')]
				print text
				self.wfile.write("Encrypted: " + str(en(text, 1673538652390923)))
				self.wfile.write("\n")
				print "Close connection."
			except:
				self.wfile.write("Unrecognized input. Close connection.")
				self.wfile.write("\n")
				print "input error:" + text
	server = Server(('', 8097), Handler)
	server.serve_forever()

所以，用得出来的key，和ECB模式的AES的cipher来decrypt十六进制解码之后的密文，结果就是：

	>>> cipher.decrypt(a.decode('hex'))
	'4b7a416d4d536f314c444d724f436f304a7a6b754e7963784b7a49714e7967324c4449704e6934354c44496d4d4359774b5459734e6934784b4449714f5373784a7a51704d6967324b7a41714e53347a4c7a4d734d536b334c6a55724e5334344c44516f4f4377784b5459714f5334314b5463744d79677a4b4467734d6959784c6a6b714e53343d'

再十六进制解码，得：

	>>> b.decode('hex')
	'KzAmMSo1LDMrOCo0JzkuNycxKzIqNyg2LDIpNi45LDImMCYwKTYsNi4xKDIqOSsxJzQpMig2KzAqNS4zLzMsMSk3LjUrNS44LDQoOCwxKTYqOS41KTctMygzKDgsMiYxLjkqNS4='

明显是个base64编码后的string，用base64解码，得：

	>>> base64.b64decode(b.decode('hex'))
	"+0&1*5,3+8*4'9.7'1+2*7(6,2)6.9,2&0&0)6,6.1(2*9+1'4)2(6+0*5.3/3,1)7.5+5.8,4(8,1)6*9.5)7-3(3(8,2&1.9*5."

和当年一开始学ASCII的时候把英文转化为ASCII码减去一定的数字再还原得到的东西一样，需要找中间减去的数字还原得到：

	'50014563584419871152472662368962000036668122495114322650458393613785558864286136498537732328620189458'

然后，这串数字转成十六进制后再用.decode(‘hex’)：

	>>> b
	'5B77333163306D332C206D7920667231656E64242E5D20666C3467724074776F666F75727468732E6712'
	>>> b.decode('hex')
	'[w31c0m3, my fr1end$.] fl4gr@twofourths.g\x12'

其实和原文还有差距，但是题目的提示中提到了，第一次是异或加密，而且数字不会很大。同时，在一般情况下，异或加密只会对最后的产生影响。然而，邮箱似乎给码掉了？有两种方法来解决：

方法一：其实，题目里已经给出了ip地址了，只要反查一下上面的域名就好了，补齐码掉的就好了

方法二：破解出异或用的key （我才不会告诉你是2679！）

以上。
